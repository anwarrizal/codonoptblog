"""Utilities for analyzing and manipulating codon usage frequencies in DNA sequences.

This module provides functions for:
- Generating DNA sequences from protein sequences
- Analyzing codon usage frequencies from FASTA files
- Visualizing relative synonymous codon usage (RSCU)
- Converting proteins to DNA using codon bias preferences

The module supports both deterministic and probabilistic approaches for DNA sequence generation,
allowing for creation of sequences that match observed codon usage patterns.
"""

from collections import defaultdict
from collections.abc import Generator
import random
from typing import TypeAlias

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

CODON_TABLE = {
    "A": ["GCT", "GCC", "GCA", "GCG"],
    "C": ["TGT", "TGC"],
    "D": ["GAT", "GAC"],
    "E": ["GAA", "GAG"],
    "F": ["TTT", "TTC"],
    "G": ["GGT", "GGC", "GGA", "GGG"],
    "H": ["CAT", "CAC"],
    "I": ["ATT", "ATC", "ATA"],
    "K": ["AAA", "AAG"],
    "L": ["TTA", "TTG", "CTT", "CTC", "CTA", "CTG"],
    "M": ["ATG"],
    "N": ["AAT", "AAC"],
    "P": ["CCT", "CCC", "CCA", "CCG"],
    "Q": ["CAA", "CAG"],
    "R": ["CGT", "CGC", "CGA", "CGG", "AGA", "AGG"],
    "S": ["TCT", "TCC", "TCA", "TCG", "AGT", "AGC"],
    "T": ["ACT", "ACC", "ACA", "ACG"],
    "V": ["GTT", "GTC", "GTA", "GTG"],
    "W": ["TGG"],
    "Y": ["TAT", "TAC"],
    "*": ["TAA", "TGA", "TAG"],
}


def generate_all_sequences_recursive(
    protein: str,
    codon_table: dict[str, list[str]],
    position: int = 0,
    current: str = "",
) -> list[str]:
    """Recursively generates all possible DNA sequences that could encode a given protein sequence.

    This function uses a recursive approach to build all possible DNA sequences by considering
    all valid codons for each amino acid in the protein sequence. It explores each possible
    combination of codons that could encode the protein.

    Args:
        protein (str): The protein sequence to encode, represented as a string of amino acid
            single-letter codes.
        codon_table (dict[str, list[str]]): A dictionary mapping amino acid single-letter
            codes to lists of possible codons that encode them.
        position (int, optional): The current position in the protein sequence being processed.
            Used for recursive calls. Defaults to 0.
        current (str, optional): The partially built DNA sequence. Used for recursive calls.
            Defaults to empty string.

    Returns:
        list[str]: A list of all possible DNA sequences that could encode the input protein.
        Each sequence will be 3 times the length of the input protein sequence.

    Example:
        >>> codon_table = {"M": ["ATG"], "Y": ["TAT", "TAC"], "L": ["TTA", "TTG"]}
        >>> generate_all_sequences_recursive("MYL", codon_table)
        ['ATGTATTTA', 'ATGTATTTG', 'ATGTACTTA', 'ATGTACTTG']
    """
    # Base case: we've processed all amino acids
    if position == len(protein):
        return [current]

    # Get the current amino acid
    aa = protein[position]

    # Recursive case: try all possible codons for this amino acid
    all_sequences = []
    for codon in codon_table[aa]:
        # Add all sequences that can be generated by appending this codon
        all_sequences.extend(
            generate_all_sequences_recursive(
                protein, codon_table, position + 1, current + codon
            )
        )

    return all_sequences


def generate_all_sequences_generator(
    protein: str,
    codon_table: dict[str, list[str]],
    position: int = 0,
    current: str = "",
) -> Generator:
    """Generates all possible DNA sequences that could encode a given protein sequence.

    This function uses a generator approach to yield all possible DNA sequences by considering
    all valid codons for each amino acid in the protein sequence. It explores each possible
    combination of codons that could encode the protein, yielding sequences one at a time
    to conserve memory.

    Args:
        protein (str): The protein sequence to encode, represented as a string of amino acid
            single-letter codes.
        codon_table (dict[str, list[str]]): A dictionary mapping amino acid single-letter
            codes to lists of possible codons that encode them.
        position (int, optional): The current position in the protein sequence being processed.
            Used for recursive calls. Defaults to 0.
        current (str, optional): The partially built DNA sequence. Used for recursive calls.
            Defaults to empty string.

    Yields:
        str: Each possible DNA sequence that could encode the input protein.
            Each sequence will be 3 times the length of the input protein sequence.

    Example:
        >>> codon_table = {"M": ["ATG"], "Y": ["TAT", "TAC"], "L": ["TTA", "TTG"]}
        >>> generator = generate_all_sequences_generator("MYL", codon_table)
        >>> list(generator)
        ['ATGTATTTA', 'ATGTATTTG', 'ATGTACTTA', 'ATGTACTTG']
    """

    # Base case: we've processed all amino acids
    if position == len(protein):
        yield current
        return

    # Get the current amino acid
    aa = protein[position]

    # Recursive case: try all possible codons for this amino acid
    for codon in codon_table[aa]:
        # Yield all sequences that can be generated by appending this codon
        yield from generate_all_sequences_generator(
            protein, codon_table, position + 1, current + codon
        )


def read_fasta(file_path: str) -> Generator[str]:
    """Read a FASTA file and yield sequences.
    Args:
      file_path(str): Path to the fasta file.
    Yield:
      Generator of DNA sequence.
    """
    current_sequence: list[str] = []

    with open(file_path, encoding="utf-8") as f:
        for line in f:
            if not (line := line.strip()):
                continue
            if line and line.startswith(">"):
                if current_sequence:
                    yield "".join(current_sequence)
                current_sequence = []
            else:
                current_sequence.append(line)

    if current_sequence:
        yield "".join(current_sequence)


def get_codons(sequence: str) -> list[str]:
    """Gets all codons from a given sequence.
    Args:
        sequence(str): The sequence
    Returns:
        The list of codons of the sequence.
    """
    return [
        sequence[i : i + 3]
        for i in range(0, len(sequence), 3)
        if len(sequence[i : i + 3]) == 3 and "N" not in sequence[i : i + 3]
    ]


CounterDict: TypeAlias = dict[str, int]
"""A dictionary that maps strings to their counts.

Used for storing frequency counts of codons or amino acids in DNA/protein sequences.

Example:
    codon_counts: CounterDict = {"ATG": 10, "GCC": 5}
    aa_counts: CounterDict = {"M": 10, "A": 5}
"""


def count_codons(
    fasta_path: str, codon_table: dict[str, list[str]]=CODON_TABLE
) -> tuple[CounterDict, CounterDict]:
    """Count codons and amino acids in a FASTA file.

    Args:
        fasta_path: Path to the FASTA file
        codon_table: Dictionary mapping amino acids to their codons

    Returns:
        Tuple of (codon_counts, aa_counts) dictionaries
    """
    # Initialize counters
    codon_counts: CounterDict = defaultdict(int)
    aa_counts: CounterDict = defaultdict(int)

    # Create reverse lookup for codons to amino acids
    codon_to_aa = {codon: aa for aa, codons in codon_table.items() for codon in codons}

    # Count codons
    for sequence in read_fasta(fasta_path):
        codons = get_codons(sequence.upper())
        for codon in codons:
            if codon in codon_to_aa:
                codon_counts[codon] += 1
                aa_counts[codon_to_aa[codon]] += 1

    return codon_counts, aa_counts


def visualize_rscu(
    df: pd.DataFrame,
    output_path: str,
    codon_table: dict[str, list[str]],
    figsize: tuple[int, int] = (24, 16),
    cmap: str = "YlOrRd",
) -> None:
    """Create and save a heatmap visualization of RSCU values with codons
    grouped by amino acid.

    Args:
        df (DataFrame): DataFrame containing RSCU data with Codon and
            Amino_Acid columns
        output_path(str): Path where to save the PNG file
        codon_table(dict): Dictionary mapping amino acids to their codons
        figsize (tuple): Tuple of (width, height) for the figure
        cmap (str): Color map to use for the heatmap
    """

    # Create ordered list of codons grouped by amino acid
    ordered_codons = []
    for aa in sorted(codon_table.keys()):
        ordered_codons.extend(codon_table[aa])

    # Sort amino acids alphabetically
    ordered_aa = sorted(codon_table.keys())

    # Pivot the data to create a matrix suitable for heatmap
    rscu_matrix = df.pivot(index="Amino_Acid", columns="Codon", values="RSCU")

    # Reorder columns (codons) and index (amino acids)
    rscu_matrix = rscu_matrix.reindex(columns=ordered_codons)
    rscu_matrix = rscu_matrix.reindex(index=ordered_aa)

    # Create figure and axes with specified size
    plt.figure(figsize=figsize)

    # Create heatmap
    sns.heatmap(
        rscu_matrix,
        cmap=cmap,
        center=1.0,
        annot=True,
        fmt=".2f",
        cbar_kws={"label": "RSCU"},
        square=True,
    )

    # Define the title and labels
    plt.title("Relative Synonymous Codon Usage (RSCU)", pad=20)
    plt.xlabel("Codon", labelpad=10)
    plt.ylabel("Amino Acid", labelpad=10)

    # Rotate x-axis labels for better readability
    plt.xticks(rotation=45, ha="right")

    # Adjust layout to prevent label cutoff
    plt.tight_layout()

    # Save the plot
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()


def protein_to_dna_preferred(protein_sequence: str, frequency_df: pd.DataFrame) -> str:
    """Convert a protein sequence to DNA sequence using preferred codons
    based on a codon bias table.

    Args:
        protein_sequence (str): The amino acid sequence to convert
        frequency_df (pd.DataFrame): DataFrame containing codon bias analysis
             results

    Returns:
        str: The DNA sequence using preferred codons
    """
    # Create a mapping of amino acids to their preferred codons
    preferred_codons = {}

    # Group by Amino_Acid and find the codon with highest usage for each
    for aa, group in frequency_df.groupby("Amino_Acid"):
        # Get the codon with highest count
        preferred_codon = group.loc[group["Codon_Total_Count"].idxmax(), "Codon"]
        preferred_codons[aa] = preferred_codon

    # Convert the protein sequence to DNA
    dna_sequence: str = ""
    for aa in protein_sequence.upper():
        if aa in preferred_codons:
            dna_sequence += str(preferred_codons[aa])
        else:
            raise ValueError(f"Unknown amino acid: {aa}")

    return dna_sequence


def protein_to_dna_weighted(protein_sequence: str, frequency_df: pd.DataFrame) -> str:
    """Convert a protein sequence to DNA sequence by sampling codons based on their usage frequency.

    Args:
        protein_sequence (str): The amino acid sequence to convert
        frequency_df (pd.DataFrame): DataFrame containing codon usage
          analysis results

    Returns:
        str: The DNA sequence with codons sampled according to their
          frequencies
    """
    # Create a mapping of amino acids to their codons and frequencies
    codon_probabilities = {}

    # Group by Amino_Acid and calculate probabilities for each codon
    for aa, group in frequency_df.groupby("Amino_Acid"):
        codons = group["Codon"].tolist()
        frequencies = group["Fraction"].tolist()

        # Store codons and their probabilities for each amino acid
        codon_probabilities[aa] = (codons, frequencies)

    # Convert the protein sequence to DNA by sampling codons
    dna_sequence = ""
    for aa in protein_sequence.upper():
        if aa in codon_probabilities:
            codons, probabilities = codon_probabilities[aa]
            # Sample a codon based on the frequency distribution
            chosen_codon = random.choices(codons, weights=probabilities, k=1)[0]
            dna_sequence += chosen_codon
        else:
            raise ValueError(f"Unknown amino acid: {aa}")

    return dna_sequence


def generate_multiple_variants(
    protein_sequence: str, frequency_df: pd.DataFrame, num_variants: int = 5
) -> list[str]:
    """Generate multiple DNA sequence variants for a given protein sequence.

    Args:
        protein_sequence (str): The amino acid sequence to convert
        frequency_df (pd.DataFrame): DataFrame containing codon usage analysis results
        num_variants (int): Number of variant sequences to generate

    Returns:
        list[str]: List of DNA sequence variants
    """
    return [
        protein_to_dna_weighted(protein_sequence, frequency_df)
        for _ in range(num_variants)
    ]

import pandas as pd

def analyze_codon_counts(
    codon_counts: CounterDict, 
    aa_counts: CounterDict, 
    codon_table: dict[str, list[str]]=CODON_TABLE
) -> pd.DataFrame:
    """Analyze codon usage from count data and return results as a DataFrame.
    
    Args:
        codon_counts (CounterDict): Dictionary of codon counts
        aa_counts (CounterDict): Dictionary of amino acid counts
        codon_table (dict): Dictionary mapping amino acids to their codons
    
    Returns:
        DataFrame with codon usage analysis
    """
    results = []
    
    for aa, codons in codon_table.items():
        # Skip if no occurrences of this amino acid
        # This should not happen in real data though.
        if aa_counts[aa] == 0:
            continue
            
        # Calculate RSCU, fraction, etc values
        expected_frequency = 1 / len(codons)
        max_count = max(codon_counts[codon] for codon in codons)
        for codon in codons:
            count = codon_counts[codon]
            fraction = count / aa_counts[aa] if aa_counts[aa] > 0 else 0
            rscu = ( fraction / expected_frequency 
                       if expected_frequency > 0 else 0 )
            
            results.append({
                'Codon': codon,
                'Amino_Acid': aa,
                'Preferred': count > 0 and count == max_count,
                'Codon_Total_Count': count,
                'Fraction': fraction,
                'RSCU': rscu
            })
    
    # Convert to DataFrame and sort
    df = pd.DataFrame(results)
    df = df.astype({
        'Codon': 'string',
        'Amino_Acid': 'string',
        'Preferred': 'bool',
        'Codon_Total_Count': 'int64',
        'Fraction': 'float64',
        'RSCU': 'float64'
    })
    df = df.sort_values(['Amino_Acid', 'Codon_Total_Count'], 
              ascending=[True, False])
  
    return df

def analyze_fasta(fasta_path: str, csv_output: str, output_path: str | None = None) -> None:
    """Analyze codon frequencies in FASTA file and create visualization."""
    # Count codons and amino acids
    codon_counts, aa_counts = count_codons(fasta_path, CODON_TABLE)
    df = analyze_codon_counts(
        codon_counts, aa_counts, CODON_TABLE
    )
    df.to_csv(csv_output, index=False, header=True)
    
    # Create visualization
    if output_path:
        visualize_rscu(df, output_path, CODON_TABLE)
    return df


def create_csv_and_visualization(df: pd.DataFrame, csv_output: str, output_path: str|None) -> None:
    df.to_csv(csv_output, index=False, header=True)

    # Create visualization
    if output_path:
        visualize_rscu(df, output_path, CODON_TABLE)
    return df
